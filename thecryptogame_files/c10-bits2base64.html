

<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title> Bits to Base64 </title>

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="keywords" content="Bits to base64 conversion tools Cryptolab Cryptogame">
	<meta name="description" content="base64 is a group of similar bits-to-text encoding schemes to represent any data in an ASCII string of printable characters. It is good and safe for transmission across a medium.">
	<meta name="author" content="dev">

	<link rel="shortcut icon" href="images/favicon.ico">

	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- 
		SETUP COMMON CSS & JS FILES 
	-->
	<script type="text/javascript" src="lib/jquery-1.12.1.min.js"></script>

	<!-- setup materialize.-->
	<!-- 1. import google icon font -->
		<!-- for offline case -->
	<link rel="stylesheet" href="lib/materialize/iconfont/material-icons.css">
		<!-- or, if online 
	<link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		-->
	<!-- 2. import materialize.css -->
	<link rel="stylesheet" href="lib/materialize/css/materialize.min.css" media="screen,projection">
	<!-- 3. import materilize.js (make sure jquery has already been included) -->
	<script type="text/javascript" src="lib/materialize/js/materialize.min.js"></script>

	<script type="text/javascript" src="lib/validate.min.js"></script>


	<!-- my js: some greet functions; text resize on copy paste, etc.-->
	<script type="text/javascript" src="lib/my/main.js"></script>
	<link rel="stylesheet" href="lib/my/main.css"><script src="lib/my/main.js"></script>
</head>
<body>
<!-- 
	Code Begins 
-->


<div class="container">
	<div class="row center-align">
		<a href="cryptolab.html" style="color:#00838f">&larr; Back</a>
	</div>

	<!-- Horizontal Tab -->
	<div class="row">
		<div class="col s4">
			<h4>Bits to Base64</h4>
		</div>
		 <div class="col s6 offset-s2 card">
	      <ul class="tabs">
	        <li class="tab col s3"><a href="#tool">Tool</a></li>
	        <li class="tab col s3"><a href="#descp" class="active">About</a></li>
	      </ul>
	    </div>
	</div>


	<!-- Items Detailed -->
	<div class="row">
		<div id="descp" class="col s12">
			
	<!-- Short description about caesar cipher -->
	<div class="row">
		<div class="col s2"><br><strong>How</strong></div>
		<div class="col s8 paper-bg" >
			<p>
				<span id="greet"></span> Welcome again.<br><br>

				Base64 is a mechanism to enable representing and transferring binary data over mediums that allow only printable characters.<br><br>

				The 64 characters used in this technique are:<br>
				<pre>
Value	Char	Value	Char	Value	Char	Value	Char
0	A	16	Q	32	g	48	w
1	B	17	R	33	h	49	x
2	C	18	S	34	i	50	y
3	D	19	T	35	j	51	z
4	E	20	U	36	k	52	0
5	F	21	V	37	l	53	1
6	G	22	W	38	m	54	2
7	H	23	X	39	n	55	3
8	I	24	Y	40	o	56	4
9	J	25	Z	41	p	57	5
10	K	26	a	42	q	58	6
11	L	27	b	43	r	59	7
12	M	28	c	44	s	60	8
13	N	29	d	45	t	61	9
14	O	30	e	46	u	62	+
15	P	31	f	47	v	63	/
				</pre>
				The character '=' is also used. (for 'padding' purposes)<br><br>

				Let's understand by few examples.<br><br>

				<strong>Example 1</strong><br>
				Suppose you have a text: "Man". Let's encode it into Base64.<br>
				Encoded in ASCII, the characters 'M', 'a' and 'n' are stored as the bytes 77, 97 and 110; or 01001101, 01100001, 01101110. <br>
				Then, these are joined into a '24'-bit string, producing: 010011010110000101101110<br>
				Now, it is grouped into 6 bits from left-to-right, like: 010011, 010110, 000101, 101110; This gives the Values: 19, 22, 5 and 46; or the characters: T, W, F and u.<br>
				That's it. That's the base64 encoded value of "Man": "TWFu"<br><br>

				In the above case, the number of bits were 24 i.e. divisible by 6. But when the number of bits in the string will not be divisible exactly by 6, then what will we do? Let's see.<br><br>

				<strong>Example 2</strong><br>
				Suppose you have a text: "M". Let's encode it into Base64.<br>
				Encoded in ASCII, the characters 'M' is stored as the byte 77; or 01001101. <br>
				Making it into a '24'-bit string, gives: 010011010000000000000000<br>
				Note that we just added or 'padded' zeroes in the end.<br>
				Now, it is grouped into 6 bits from left-to-right, like: 010011, 010000, 000000, 000000; This gives the Values: 19, 16, 0 and 0; or the characters: T, Q, = and =.<br>Note that 0 means A, but since these are in the end for padding-purpose, '=' sign is used instead.<br>
				That's it. That's the base64 encoded value of "M": "TW=="<br><br>

				<strong>Example 3</strong><br>
				Suppose you have a text: "Ma". Let's encode it into Base64.<br>
				Encoded in ASCII, the characters 'M' is stored as the byte 77 and 97; or 01001101 and 01100001. <br>
				Making it into a '24'-bit string, gives: 010011010110000100000000<br>
				Note that we just added or 'padded' zeroes in the end.<br>
				Now, it is grouped into 6 bits from left-to-right, like: 010011, 010110, 000100, 000000; This gives the Values: 19, 22, 4 and 0; or the characters: T, W, E and =.<br>
				That's it. That's the base64 encoded value of "Ma": "TWE="<br><br>


				<em>Note:</em> The Binary-to-Base64 conversion in the given 'Tool' works fine only when the input binary string is greater than 8 bits (as it actually is in the real world scenarios).
			</p>
		</div>
	</div>


	<div class="row">
		<div class="col s2"><br><strong>Next</strong></div>
		<div class="col s8 paper-bg" >
			<p>
				We have seen what is binary and what are few encoding schemes related to binary.
				Since, now we know how messages can be converted into 'binary', our real task begins; which is to encrypt those original-plain-bits to cipher-bits (using some key-bits).<br>
				To do that, we will first need to explore various 'operations' that can be performed over bits; and then, choose some 'appropriate' operation (or, devise a mechanism which uses that 'appropriate' operation) as our technique for encryption and decryption.<br>
				That's next.<br><br>

				See you there.<br>
				Bye till then.<br>
				:-)<br><br>

				Post-14 Ended.

			</p>
		</div>
	</div>


			</div>
		<div id="tool" id="descp-div" class="col s12 card center-align">
			
	<!-- <p>Conversion tool to go here - a form element with input String, settings &amp; output strings.</p> -->

	<!-- input Area -->
	<br>	<!-- just empty space -->
	<div class="row">
      <div class="input-field col s8 offset-s2">
        <textarea id="inputString" class="materialize-textarea"></textarea>
        <label for="inputString">Input String</label>
      </div>
    </div>


	  <!-- Switch -->
	  <div class="switch">
	    <label>
	      Encode (Binary-to-Base64)
	      <input id="mode" type="checkbox">
	      <span class="lever"></span>
	      Decode (Base64-to-Binary)
	    </label>
	  </div>

	  <br><br>

    <!-- Compute button -->
    <a id="compute-btn" class="btn-floating btn-large waves-effect waves-light cyan darken-3 tooltipped" data-position="right" data-delay="50" data-tooltip="Convert"><i class="material-icons">done</i></a>

	<!-- output Area -->
	<div class="row">
      <div class="input-field col s8 offset-s2">
        <textarea id="outputString" class="materialize-textarea" placeholder="Output Will Be Displayed Here..." readonly="readonly" style="color:black"></textarea>
        <label for="outputString" style="color:#9e9e9e">Output String</label>
      </div>
    </div>

			</div>
	</div>
</div>



<script type="text/javascript">
//To Compute the given input to output.

$(document).ready(function(){
	//empty !
});



//whenever compute button is clicked.
$("#compute-btn").click(function(){
	var iString = $.trim($("#inputString").val());
	var oString = "";
	$("#outputString").text(oString);	//clear the oString box first.

	//step - 1: is input string empty?
	if(iString == ""){
		oString = "Please enter some Input String first.";
		Materialize.toast(oString, 4000);
	}else{

		var mode = $("#mode").prop("checked"); 	//mode: true => decode; false => encode
		

		oString = b64bin(iString, mode);
		$("#outputString").text(oString);
		$('#outputString').trigger('autoresize');
	}
});


//Ascii to binary
function toBinary(str, spaceSeparatedOctets) {
    return str.replace(/[\s\S]/g, function(str) {
      str = zeroPad(str.charCodeAt().toString(2));
      return !1 == spaceSeparatedOctets ? str : str + " "
    });
}
function zeroPad(num) {
    return "00000000".slice(String(num).length) + num;
}
//Binary string to Ascii.
function toAscii(bin){
			    return bin.replace(/\s*[01]{8}\s*/g, function(bin) {
			      return String.fromCharCode(parseInt(bin, 2));
		    	});
			}

//Our main JS function for this Cipher technique
//Parameters:- iString: string, mode: false[encode]/true[decode]
function b64bin(iString, mode){
	var oString = "";

	if(mode == false){			//meaning, 'encode' mode selected. (binary-to-base64)

		//check if anything other than binary inputted!
		if(iString.match('[^10 ]')){ //meaning, not a valid 'binary'
			oString = "Make sure you are Encoding a Valid Binary!";
			Materialize.toast(oString, 4000);
			return "";
		}
		else{	//binary input is valid.
			

			iString = iString.replace(/[ ]/g, "");

			oString = toAscii(iString);	//binary string to Ascii
			oString = btoa(oString);	//Ascii to B64


			//to display in a nice-order
			if(iString.length % 24 != 0){
				//then, make so.
				for(var i=0; iString.length % 24 != 0 ;i++){
					iString += "0";
				}
			}
			iString = iString.replace(/(.{6})/g,"$1 ");
			$("#inputString").val(iString);


			//...otherwise, continue as normal.
			return oString;
		}

	}else{						//meaning, 'decode' mode selected. (base64-to-binary)

		//check if anything other than base64 inputted.
		//if(iString.match('[^-A-Za-z0-9+/= ]')){	
		var base64Matcher = new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$");

		if (!base64Matcher.test(iString)) {//meaning, not a 'valid' base64
			oString = "Make sure you are Decoding a Valid Base64 String!";
			Materialize.toast(oString, 4000);
			return "";
		}

		//if above good, then: first, remove all the spaces.
		iString = iString.replace(/[ ]/g, "");


	    oString = atob(iString);	//base64 to ascii
	    oString = toBinary(oString, 0);	//ascii to binary.

		//to display in a nice-order
		if(oString.length % 24 != 0){
			//then, make so.
			for(var i=0; oString.length % 24 != 0 ;i++){
				oString += "0";
			}
		}

		oString = oString.replace(/(.{6})/g,"$1 ");
		return oString;
	}

}
</script>


<!-- 
	Code Ends 
-->

	


</body>
</html>
